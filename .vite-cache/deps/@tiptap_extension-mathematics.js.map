{
  "version": 3,
  "sources": ["../../node_modules/@tiptap/extension-mathematics/src/MathematicsPlugin.ts", "../../node_modules/@tiptap/extension-mathematics/src/mathematics.ts"],
  "sourcesContent": ["import { getChangedRanges } from '@tiptap/core'\nimport {\n  EditorState, Plugin, PluginKey, Transaction,\n} from '@tiptap/pm/state'\nimport { Decoration, DecorationSet } from '@tiptap/pm/view'\nimport katex from 'katex'\n\nimport { MathematicsOptionsWithEditor } from './types.js'\n\ntype DecoSpec = {\n  isEditable: boolean;\n  isEditing: boolean;\n  katexOptions: MathematicsOptionsWithEditor['katexOptions'];\n  content: string;\n};\n\ntype Deco = Omit<Decoration, 'spec'> & { spec: DecoSpec };\n\ntype PluginState =\n| { decorations: DecorationSet; isEditable: boolean }\n| { decorations: undefined; isEditable: undefined }\n\n/**\n * Get the range of positions that have been affected by a transaction\n */\nfunction getAffectedRange(newState: EditorState, previousPluginState: PluginState, isEditable: boolean, tr: Transaction, state: EditorState) {\n  const docSize = newState.doc.nodeSize - 2\n  let minFrom = 0\n  let maxTo = docSize\n\n  if (previousPluginState.isEditable !== isEditable) {\n    // When the editable state changes, run on all nodes just to be safe\n    minFrom = 0\n    maxTo = docSize\n  } else if (tr.docChanged) {\n    // When the document changes, only run on the nodes that have changed\n    minFrom = docSize\n    maxTo = 0\n\n    getChangedRanges(tr).forEach(range => {\n      // Purposefully over scan the range to ensure we catch all decorations\n      minFrom = Math.min(minFrom, range.newRange.from - 1, range.oldRange.from - 1)\n      maxTo = Math.max(maxTo, range.newRange.to + 1, range.oldRange.to + 1)\n    })\n  } else if (tr.selectionSet) {\n    const { $from, $to } = state.selection\n    const { $from: $newFrom, $to: $newTo } = newState.selection\n\n    // When the selection changes, run on all the nodes between the old and new selection\n    minFrom = Math.min(\n      // Purposefully over scan the range to ensure we catch all decorations\n      $from.depth === 0 ? 0 : $from.before(),\n      $newFrom.depth === 0 ? 0 : $newFrom.before(),\n    )\n    maxTo = Math.max(\n      $to.depth === 0 ? maxTo : $to.after(),\n      $newTo.depth === 0 ? maxTo : $newTo.after(),\n    )\n  }\n\n  return {\n    minFrom: Math.max(minFrom, 0),\n    maxTo: Math.min(maxTo, docSize),\n  }\n}\n\nexport const MathematicsPlugin = (options: MathematicsOptionsWithEditor) => {\n  const {\n    regex, katexOptions = {}, editor, shouldRender,\n  } = options\n\n  return new Plugin<PluginState>({\n    key: new PluginKey('mathematics'),\n\n    state: {\n      init() {\n        return { decorations: undefined, isEditable: undefined }\n      },\n      apply(tr, previousPluginState, state, newState) {\n\n        if (!tr.docChanged && !tr.selectionSet && previousPluginState.decorations) {\n          // Just reuse the existing decorations, since nothing should have changed\n          return previousPluginState\n        }\n\n        const nextDecorationSet = (previousPluginState.decorations || DecorationSet.empty).map(\n          tr.mapping,\n          tr.doc,\n        )\n        const { selection } = newState\n        const isEditable = editor.isEditable\n        const decorationsToAdd = [] as Deco[]\n        const { minFrom, maxTo } = getAffectedRange(newState, previousPluginState, isEditable, tr, state)\n\n        newState.doc.nodesBetween(minFrom, maxTo, (node, pos) => {\n          const enabled = shouldRender(newState, pos, node)\n\n          if (node.isText && node.text && enabled) {\n            let match: RegExpExecArray | null\n\n            // eslint-disable-next-line no-cond-assign\n            while ((match = regex.exec(node.text))) {\n              const from = pos + match.index\n              const to = from + match[0].length\n              const content = match.slice(1).find(Boolean)\n\n              if (content) {\n                const selectionSize = selection.from - selection.to\n                const anchorIsInside = selection.anchor >= from && selection.anchor <= to\n                const rangeIsInside = selection.from >= from && selection.to <= to\n                const isEditing = (selectionSize === 0 && anchorIsInside) || rangeIsInside\n\n                if (\n                  // Are the decorations already present?\n                  nextDecorationSet.find(\n                    from,\n                    to,\n                    (deco: DecoSpec) => isEditing === deco.isEditing\n                      && content === deco.content\n                      && isEditable === deco.isEditable\n                      && katexOptions === deco.katexOptions,\n                  ).length\n                ) {\n                  // Decoration exists in set, no need to add it again\n                  continue\n                }\n                // Use an inline decoration to either hide original (preview is showing) or show it (editing \"mode\")\n                decorationsToAdd.push(\n                  Decoration.inline(\n                    from,\n                    to,\n                    {\n                      class:\n                        isEditing && isEditable\n                          ? 'Tiptap-mathematics-editor'\n                          : 'Tiptap-mathematics-editor Tiptap-mathematics-editor--hidden',\n                      style:\n                        !isEditing || !isEditable\n                          ? 'display: inline-block; height: 0; opacity: 0; overflow: hidden; position: absolute; width: 0;'\n                          : undefined,\n                    },\n                    {\n                      content,\n                      isEditable,\n                      isEditing,\n                      katexOptions,\n                    } satisfies DecoSpec,\n                  ),\n                )\n\n                if (!isEditable || !isEditing) {\n                  // Create decoration widget and add KaTeX preview if selection is not within the math-editor\n                  decorationsToAdd.push(\n                    Decoration.widget(\n                      from,\n                      () => {\n                        const element = document.createElement('span')\n\n                        // TODO: changeable class names\n                        element.classList.add('Tiptap-mathematics-render')\n\n                        if (isEditable) {\n                          element.classList.add('Tiptap-mathematics-render--editable')\n                        }\n\n                        try {\n                          katex.render(content!, element, katexOptions)\n                        } catch {\n                          element.innerHTML = content!\n                        }\n\n                        return element\n                      },\n                      {\n                        content,\n                        isEditable,\n                        isEditing,\n                        katexOptions,\n                      } satisfies DecoSpec,\n                    ),\n                  )\n                }\n              }\n            }\n          }\n        })\n\n        // Remove any decorations that exist at the same position, they will be replaced by the new decorations\n        const decorationsToRemove = decorationsToAdd.flatMap(deco => nextDecorationSet.find(deco.from, deco.to))\n\n        return {\n          decorations: nextDecorationSet\n            // Remove existing decorations that are going to be replaced\n            .remove(decorationsToRemove)\n            // Add any new decorations\n            .add(tr.doc, decorationsToAdd),\n          isEditable,\n        }\n      },\n    },\n\n    props: {\n      decorations(state) {\n        return this.getState(state)?.decorations ?? DecorationSet.empty\n      },\n    },\n  })\n}\n", "import { Extension } from '@tiptap/core'\nimport { EditorState } from '@tiptap/pm/state'\n\nimport { MathematicsPlugin } from './MathematicsPlugin.js'\nimport { MathematicsOptions } from './types.js'\n\nexport const defaultShouldRender = (state: EditorState, pos: number) => {\n  const $pos = state.doc.resolve(pos)\n  const isInCodeBlock = $pos.parent.type.name === 'codeBlock'\n\n  return !isInCodeBlock\n}\n\nexport const Mathematics = Extension.create<MathematicsOptions>({\n  name: 'Mathematics',\n\n  addOptions() {\n    return {\n      // eslint-disable-next-line no-useless-escape\n      regex: /\\$([^\\$]*)\\$/gi,\n      katexOptions: undefined,\n      shouldRender: defaultShouldRender,\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [MathematicsPlugin({ ...this.options, editor: this.editor })]\n  },\n})\n\nexport default Mathematics\n"],
  "mappings": "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",
  "names": []
}
