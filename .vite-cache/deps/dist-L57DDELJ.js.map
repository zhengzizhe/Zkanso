{
  "version": 3,
  "sources": ["../../node_modules/@excalidraw/markdown-to-text/dist/index.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/constants.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/GraphConverter.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/interfaces.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/helpers.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/flowchart.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/node_modules/nanoid/index.browser.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/graphImage.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/transformToExcalidrawSkeleton.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/sequence.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/converter/types/class.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/graphToExcalidraw.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/node_modules/mermaid/dist/mermaid.core.mjs", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/utils.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/flowchart.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/elementSkeleton.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/sequence.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/parser/class.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/parseMermaid.js", "../../node_modules/@excalidraw/mermaid-to-excalidraw/dist/index.js"],
  "sourcesContent": ["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeMarkdown = void 0;\n/**\n * @function removeMarkdown\n *\n * @description\n * Parse the markdown and returns a string\n *\n * @param markdown - The markdown string to parse\n * @param options - The options for the function\n *\n * @returns The parsed plain text\n */\nvar removeMarkdown = function (markdown, options) {\n    if (options === void 0) { options = {\n        listUnicodeChar: \"\",\n    }; }\n    options = options || {};\n    options.listUnicodeChar = options.hasOwnProperty(\"listUnicodeChar\")\n        ? options.listUnicodeChar\n        : false;\n    options.stripListLeaders = options.hasOwnProperty(\"stripListLeaders\")\n        ? options.stripListLeaders\n        : true;\n    options.gfm = options.hasOwnProperty(\"gfm\") ? options.gfm : true;\n    options.useImgAltText = options.hasOwnProperty(\"useImgAltText\")\n        ? options.useImgAltText\n        : true;\n    options.preserveLinks = options.hasOwnProperty(\"preserveLinks\")\n        ? options.preserveLinks\n        : false;\n    var output = markdown || \"\";\n    // Remove horizontal rules (stripListHeaders conflict with this rule, which is why it has been moved to the top)\n    output = output.replace(/^(-\\s*?|\\*\\s*?|_\\s*?){3,}\\s*$/gm, \"\");\n    try {\n        if (options.stripListLeaders) {\n            if (options.listUnicodeChar)\n                output = output.replace(/^([\\s\\t]*)([\\*\\-\\+]|\\d+\\.)\\s+/gm, options.listUnicodeChar + \" $1\");\n            else\n                output = output.replace(/^([\\s\\t]*)([\\*\\-\\+]|\\d+\\.)\\s+/gm, \"$1\");\n        }\n        if (options.gfm) {\n            output = output\n                // Header\n                .replace(/\\n={2,}/g, \"\\n\")\n                // Fenced codeblocks\n                .replace(/~{3}.*\\n/g, \"\")\n                // Strikethrough\n                .replace(/~~/g, \"\")\n                // Fenced codeblocks\n                .replace(/`{3}.*\\n/g, \"\");\n        }\n        if (options.preserveLinks) {\n            // Remove inline links while preserving the links\n            output = output.replace(/\\[(.*?)\\][\\[\\(](.*?)[\\]\\)]/g, \"$1 ($2)\");\n        }\n        output = output\n            // Remove HTML tags\n            .replace(/<[^>]*>/g, \"\")\n            // Remove setext-style headers\n            .replace(/^[=\\-]{2,}\\s*$/g, \"\")\n            // Remove footnotes?\n            .replace(/\\[\\^.+?\\](\\: .*?$)?/g, \"\")\n            .replace(/\\s{0,2}\\[.*?\\]: .*?$/g, \"\")\n            // Remove images\n            .replace(/\\!\\[(.*?)\\][\\[\\(].*?[\\]\\)]/g, options.useImgAltText ? \"$1\" : \"\")\n            // Remove inline links\n            .replace(/\\[(.*?)\\][\\[\\(].*?[\\]\\)]/g, \"$1\")\n            // Remove blockquotes\n            .replace(/^\\s{0,3}>\\s?/g, \"\")\n            .replace(/(^|\\n)\\s{0,3}>\\s?/g, \"\\n\\n\")\n            // Remove reference-style links?\n            .replace(/^\\s{1,2}\\[(.*?)\\]: (\\S+)( \".*?\")?\\s*$/g, \"\")\n            // Remove atx-style headers\n            .replace(/^(\\n)?\\s{0,}#{1,6}\\s+| {0,}(\\n)?\\s{0,}#{0,} {0,}(\\n)?\\s{0,}$/gm, \"$1$2$3\")\n            // Remove emphasis (repeat the line to remove double emphasis)\n            .replace(/([\\*_]{1,3})(\\S.*?\\S{0,1})\\1/g, \"$2\")\n            .replace(/([\\*_]{1,3})(\\S.*?\\S{0,1})\\1/g, \"$2\")\n            // Remove code blocks\n            .replace(/(`{3,})(.*?)\\1/gm, \"$2\")\n            // Remove inline code\n            .replace(/`(.+?)`/g, \"$1\")\n            // Replace two or more newlines with exactly two? Not entirely sure this belongs here...\n            .replace(/\\n{2,}/g, \"\\n\\n\");\n    }\n    catch (e) {\n        console.error(e);\n        return markdown;\n    }\n    return output;\n};\nexports.removeMarkdown = removeMarkdown;\n", "export const DEFAULT_FONT_SIZE = 20;\nexport const SVG_TO_SHAPE_MAPPER = {\n    rect: \"rectangle\",\n    circle: \"ellipse\",\n};\n// visit https://mermaid.js.org/schemas/config.schema.json for default schema\nexport const MERMAID_CONFIG = {\n    startOnLoad: false,\n    flowchart: { curve: \"linear\" },\n    themeVariables: {\n        // Multiplying by 1.25 to increase the font size by 25% and render correctly in Excalidraw\n        fontSize: `${DEFAULT_FONT_SIZE * 1.25}px`,\n    },\n    maxEdges: 500,\n    maxTextSize: 50000,\n};\n", "import { DEFAULT_FONT_SIZE } from \"../constants.js\";\nexport class GraphConverter {\n    constructor({ converter, }) {\n        this.convert = (graph, config) => {\n            return this.converter(graph, {\n                ...config,\n                fontSize: config.fontSize || DEFAULT_FONT_SIZE,\n            });\n        };\n        this.converter = converter;\n    }\n}\n", "export var VERTEX_TYPE;\n(function (VERTEX_TYPE) {\n    VERTEX_TYPE[\"ROUND\"] = \"round\";\n    VERTEX_TYPE[\"STADIUM\"] = \"stadium\";\n    VERTEX_TYPE[\"DOUBLECIRCLE\"] = \"doublecircle\";\n    VERTEX_TYPE[\"CIRCLE\"] = \"circle\";\n    VERTEX_TYPE[\"DIAMOND\"] = \"diamond\";\n})(VERTEX_TYPE || (VERTEX_TYPE = {}));\nexport var LABEL_STYLE_PROPERTY;\n(function (LABEL_STYLE_PROPERTY) {\n    LABEL_STYLE_PROPERTY[\"COLOR\"] = \"color\";\n})(LABEL_STYLE_PROPERTY || (LABEL_STYLE_PROPERTY = {}));\nexport var CONTAINER_STYLE_PROPERTY;\n(function (CONTAINER_STYLE_PROPERTY) {\n    CONTAINER_STYLE_PROPERTY[\"FILL\"] = \"fill\";\n    CONTAINER_STYLE_PROPERTY[\"STROKE\"] = \"stroke\";\n    CONTAINER_STYLE_PROPERTY[\"STROKE_WIDTH\"] = \"stroke-width\";\n    CONTAINER_STYLE_PROPERTY[\"STROKE_DASHARRAY\"] = \"stroke-dasharray\";\n})(CONTAINER_STYLE_PROPERTY || (CONTAINER_STYLE_PROPERTY = {}));\n", "import { CONTAINER_STYLE_PROPERTY, LABEL_STYLE_PROPERTY, } from \"../interfaces.js\";\nimport { removeMarkdown } from \"@excalidraw/markdown-to-text\";\n/**\n * Convert mermaid edge type to Excalidraw arrow type\n */\nconst MERMAID_EDGE_TYPE_MAPPER = {\n    arrow_circle: {\n        endArrowhead: \"dot\",\n    },\n    arrow_cross: {\n        endArrowhead: \"bar\",\n    },\n    arrow_open: {\n        endArrowhead: null,\n        startArrowhead: null,\n    },\n    double_arrow_circle: {\n        endArrowhead: \"dot\",\n        startArrowhead: \"dot\",\n    },\n    double_arrow_cross: {\n        endArrowhead: \"bar\",\n        startArrowhead: \"bar\",\n    },\n    double_arrow_point: {\n        endArrowhead: \"arrow\",\n        startArrowhead: \"arrow\",\n    },\n};\nexport const computeExcalidrawArrowType = (mermaidArrowType) => {\n    return MERMAID_EDGE_TYPE_MAPPER[mermaidArrowType];\n};\n// Get text from graph elements, fallback markdown to text\nexport const getText = (element) => {\n    let text = element.text;\n    if (element.labelType === \"markdown\") {\n        text = removeMarkdown(element.text);\n    }\n    return removeFontAwesomeIcons(text);\n};\n/**\n * Remove font awesome icons support from text\n */\nconst removeFontAwesomeIcons = (input) => {\n    const fontAwesomeRegex = /\\s?(fa|fab):[a-zA-Z0-9-]+/g;\n    return input.replace(fontAwesomeRegex, \"\");\n};\n/**\n * Compute style for vertex\n */\nexport const computeExcalidrawVertexStyle = (style) => {\n    const excalidrawProperty = {};\n    Object.keys(style).forEach((property) => {\n        switch (property) {\n            case CONTAINER_STYLE_PROPERTY.FILL: {\n                excalidrawProperty.backgroundColor = style[property];\n                excalidrawProperty.fillStyle = \"solid\";\n                break;\n            }\n            case CONTAINER_STYLE_PROPERTY.STROKE: {\n                excalidrawProperty.strokeColor = style[property];\n                break;\n            }\n            case CONTAINER_STYLE_PROPERTY.STROKE_WIDTH: {\n                excalidrawProperty.strokeWidth = Number(style[property]?.split(\"px\")[0]);\n                break;\n            }\n            case CONTAINER_STYLE_PROPERTY.STROKE_DASHARRAY: {\n                excalidrawProperty.strokeStyle = \"dashed\";\n                break;\n            }\n        }\n    });\n    return excalidrawProperty;\n};\n/**\n * Compute style for label\n */\nexport const computeExcalidrawVertexLabelStyle = (style) => {\n    const excalidrawProperty = {};\n    Object.keys(style).forEach((property) => {\n        switch (property) {\n            case LABEL_STYLE_PROPERTY.COLOR: {\n                excalidrawProperty.strokeColor = style[property];\n                break;\n            }\n        }\n    });\n    return excalidrawProperty;\n};\n", "import { GraphConverter } from \"../GraphConverter.js\";\nimport { getText, computeExcalidrawVertexStyle, computeExcalidrawVertexLabelStyle, computeExcalidrawArrowType, } from \"../helpers.js\";\nimport { VERTEX_TYPE } from \"../../interfaces.js\";\nconst computeGroupIds = (graph) => {\n    // Parse the diagram into a tree for rendering and grouping\n    const tree = {};\n    graph.subGraphs.map((subGraph) => {\n        subGraph.nodeIds.forEach((nodeId) => {\n            tree[subGraph.id] = {\n                id: subGraph.id,\n                parent: null,\n                isLeaf: false,\n            };\n            tree[nodeId] = {\n                id: nodeId,\n                parent: subGraph.id,\n                isLeaf: graph.vertices[nodeId] !== undefined,\n            };\n        });\n    });\n    const mapper = {};\n    [...Object.keys(graph.vertices), ...graph.subGraphs.map((c) => c.id)].forEach((id) => {\n        if (!tree[id]) {\n            return;\n        }\n        let curr = tree[id];\n        const groupIds = [];\n        if (!curr.isLeaf) {\n            groupIds.push(`subgraph_group_${curr.id}`);\n        }\n        while (true) {\n            if (curr.parent) {\n                groupIds.push(`subgraph_group_${curr.parent}`);\n                curr = tree[curr.parent];\n            }\n            else {\n                break;\n            }\n        }\n        mapper[id] = groupIds;\n    });\n    return {\n        getGroupIds: (elementId) => {\n            return mapper[elementId] || [];\n        },\n        getParentId: (elementId) => {\n            return tree[elementId] ? tree[elementId].parent : null;\n        },\n    };\n};\nexport const FlowchartToExcalidrawSkeletonConverter = new GraphConverter({\n    converter: (graph, options) => {\n        const elements = [];\n        const fontSize = options.fontSize;\n        const { getGroupIds, getParentId } = computeGroupIds(graph);\n        // SubGraphs\n        graph.subGraphs.reverse().forEach((subGraph) => {\n            const groupIds = getGroupIds(subGraph.id);\n            const containerElement = {\n                id: subGraph.id,\n                type: \"rectangle\",\n                groupIds,\n                x: subGraph.x,\n                y: subGraph.y,\n                width: subGraph.width,\n                height: subGraph.height,\n                label: {\n                    groupIds,\n                    text: getText(subGraph),\n                    fontSize,\n                    verticalAlign: \"top\",\n                },\n            };\n            elements.push(containerElement);\n        });\n        // Vertices\n        Object.values(graph.vertices).forEach((vertex) => {\n            if (!vertex) {\n                return;\n            }\n            const groupIds = getGroupIds(vertex.id);\n            // Compute custom style\n            const containerStyle = computeExcalidrawVertexStyle(vertex.containerStyle);\n            const labelStyle = computeExcalidrawVertexLabelStyle(vertex.labelStyle);\n            let containerElement = {\n                id: vertex.id,\n                type: \"rectangle\",\n                groupIds,\n                x: vertex.x,\n                y: vertex.y,\n                width: vertex.width,\n                height: vertex.height,\n                strokeWidth: 2,\n                label: {\n                    groupIds,\n                    text: getText(vertex),\n                    fontSize,\n                    ...labelStyle,\n                },\n                link: vertex.link || null,\n                ...containerStyle,\n            };\n            switch (vertex.type) {\n                case VERTEX_TYPE.STADIUM: {\n                    containerElement = { ...containerElement, roundness: { type: 3 } };\n                    break;\n                }\n                case VERTEX_TYPE.ROUND: {\n                    containerElement = { ...containerElement, roundness: { type: 3 } };\n                    break;\n                }\n                case VERTEX_TYPE.DOUBLECIRCLE: {\n                    const CIRCLE_MARGIN = 5;\n                    // Create new groupId for double circle\n                    groupIds.push(`doublecircle_${vertex.id}}`);\n                    // Create inner circle element\n                    const innerCircle = {\n                        type: \"ellipse\",\n                        groupIds,\n                        x: vertex.x + CIRCLE_MARGIN,\n                        y: vertex.y + CIRCLE_MARGIN,\n                        width: vertex.width - CIRCLE_MARGIN * 2,\n                        height: vertex.height - CIRCLE_MARGIN * 2,\n                        strokeWidth: 2,\n                        roundness: { type: 3 },\n                        label: {\n                            groupIds,\n                            text: getText(vertex),\n                            fontSize,\n                        },\n                    };\n                    containerElement = { ...containerElement, groupIds, type: \"ellipse\" };\n                    elements.push(innerCircle);\n                    break;\n                }\n                case VERTEX_TYPE.CIRCLE: {\n                    containerElement.type = \"ellipse\";\n                    break;\n                }\n                case VERTEX_TYPE.DIAMOND: {\n                    containerElement.type = \"diamond\";\n                    break;\n                }\n            }\n            elements.push(containerElement);\n        });\n        // Edges\n        graph.edges.forEach((edge) => {\n            let groupIds = [];\n            const startParentId = getParentId(edge.start);\n            const endParentId = getParentId(edge.end);\n            if (startParentId && startParentId === endParentId) {\n                groupIds = getGroupIds(startParentId);\n            }\n            // Get arrow position data\n            const { startX, startY, reflectionPoints } = edge;\n            // Calculate Excalidraw arrow's points\n            const points = reflectionPoints.map((point) => [\n                point.x - reflectionPoints[0].x,\n                point.y - reflectionPoints[0].y,\n            ]);\n            // Get supported arrow type\n            const arrowType = computeExcalidrawArrowType(edge.type);\n            const arrowId = `${edge.start}_${edge.end}`;\n            const containerElement = {\n                id: arrowId,\n                type: \"arrow\",\n                groupIds,\n                x: startX,\n                y: startY,\n                // 4 and 2 are the Excalidraw's stroke width of thick and thin respectively\n                // TODO: use constant exported from Excalidraw package\n                strokeWidth: edge.stroke === \"thick\" ? 4 : 2,\n                strokeStyle: edge.stroke === \"dotted\" ? \"dashed\" : undefined,\n                points,\n                ...(edge.text\n                    ? { label: { text: getText(edge), fontSize, groupIds } }\n                    : {}),\n                roundness: {\n                    type: 2,\n                },\n                ...arrowType,\n            };\n            // Bind start and end vertex to arrow\n            const startVertex = elements.find((e) => e.id === edge.start);\n            const endVertex = elements.find((e) => e.id === edge.end);\n            if (!startVertex || !endVertex) {\n                return;\n            }\n            containerElement.start = {\n                id: startVertex.id || \"\",\n            };\n            containerElement.end = {\n                id: endVertex.id || \"\",\n            };\n            elements.push(containerElement);\n        });\n        return {\n            elements,\n        };\n    },\n});\n", "export { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length === size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size, random)\nexport let nanoid = (size = 21) =>\n  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {\n    byte &= 63\n    if (byte < 36) {\n      id += byte.toString(36)\n    } else if (byte < 62) {\n      id += (byte - 26).toString(36).toUpperCase()\n    } else if (byte > 62) {\n      id += '-'\n    } else {\n      id += '_'\n    }\n    return id\n  }, '')\n", "import { GraphConverter } from \"../GraphConverter.js\";\nimport { nanoid } from \"nanoid\";\nexport const GraphImageConverter = new GraphConverter({\n    converter: (graph) => {\n        const imageId = nanoid();\n        const { width, height } = graph;\n        const imageElement = {\n            type: \"image\",\n            x: 0,\n            y: 0,\n            width,\n            height,\n            status: \"saved\",\n            fileId: imageId,\n        };\n        const files = {\n            [imageId]: {\n                id: imageId,\n                mimeType: graph.mimeType,\n                dataURL: graph.dataURL,\n            },\n        };\n        return { files, elements: [imageElement] };\n    },\n});\n", "export const normalizeText = (text) => {\n    return text.replace(/\\\\n/g, \"\\n\");\n};\nexport const transformToExcalidrawLineSkeleton = (line) => {\n    const lineElement = {\n        type: \"line\",\n        x: line.startX,\n        y: line.startY,\n        points: [\n            [0, 0],\n            [line.endX - line.startX, line.endY - line.startY],\n        ],\n        width: line.endX - line.startX,\n        height: line.endY - line.startY,\n        strokeStyle: line.strokeStyle || \"solid\",\n        strokeColor: line.strokeColor || \"#000\",\n        strokeWidth: line.strokeWidth || 1,\n    };\n    if (line.groupId) {\n        Object.assign(lineElement, { groupIds: [line.groupId] });\n    }\n    if (line.id) {\n        Object.assign(lineElement, { id: line.id });\n    }\n    return lineElement;\n};\nexport const transformToExcalidrawTextSkeleton = (element) => {\n    const textElement = {\n        type: \"text\",\n        x: element.x,\n        y: element.y,\n        width: element.width,\n        height: element.height,\n        text: normalizeText(element.text) || \"\",\n        fontSize: element.fontSize,\n        verticalAlign: \"middle\",\n    };\n    if (element.groupId) {\n        Object.assign(textElement, { groupIds: [element.groupId] });\n    }\n    if (element.id) {\n        Object.assign(textElement, { id: element.id });\n    }\n    return textElement;\n};\nexport const transformToExcalidrawContainerSkeleton = (element) => {\n    let extraProps = {};\n    if (element.type === \"rectangle\" && element.subtype === \"activation\") {\n        extraProps = {\n            backgroundColor: \"#e9ecef\",\n            fillStyle: \"solid\",\n        };\n    }\n    const container = {\n        id: element.id,\n        type: element.type,\n        x: element.x,\n        y: element.y,\n        width: element.width,\n        height: element.height,\n        label: {\n            text: normalizeText(element?.label?.text || \"\"),\n            fontSize: element?.label?.fontSize,\n            verticalAlign: element.label?.verticalAlign || \"middle\",\n            strokeColor: element.label?.color || \"#000\",\n            groupIds: element.groupId ? [element.groupId] : [],\n        },\n        strokeStyle: element?.strokeStyle,\n        strokeWidth: element?.strokeWidth,\n        strokeColor: element?.strokeColor,\n        backgroundColor: element?.bgColor,\n        fillStyle: \"solid\",\n        ...extraProps,\n    };\n    if (element.groupId) {\n        Object.assign(container, { groupIds: [element.groupId] });\n    }\n    return container;\n};\nexport const transformToExcalidrawArrowSkeleton = (arrow) => {\n    const arrowElement = {\n        type: \"arrow\",\n        x: arrow.startX,\n        y: arrow.startY,\n        points: arrow.points || [\n            [0, 0],\n            [arrow.endX - arrow.startX, arrow.endY - arrow.startY],\n        ],\n        width: arrow.endX - arrow.startX,\n        height: arrow.endY - arrow.startY,\n        strokeStyle: arrow?.strokeStyle || \"solid\",\n        endArrowhead: arrow?.endArrowhead || null,\n        startArrowhead: arrow?.startArrowhead || null,\n        label: {\n            text: normalizeText(arrow?.label?.text || \"\"),\n            fontSize: 16,\n        },\n        roundness: {\n            type: 2,\n        },\n        start: arrow.start,\n        end: arrow.end,\n    };\n    if (arrow.groupId) {\n        Object.assign(arrowElement, { groupIds: [arrow.groupId] });\n    }\n    return arrowElement;\n};\n", "import { nanoid } from \"nanoid\";\nimport { GraphConverter } from \"../GraphConverter.js\";\nimport { transformToExcalidrawLineSkeleton, transformToExcalidrawTextSkeleton, transformToExcalidrawContainerSkeleton, transformToExcalidrawArrowSkeleton, } from \"../transformToExcalidrawSkeleton.js\";\nexport const SequenceToExcalidrawSkeletonConvertor = new GraphConverter({\n    converter: (chart) => {\n        const elements = [];\n        const activations = [];\n        Object.values(chart.nodes).forEach((node) => {\n            if (!node || !node.length) {\n                return;\n            }\n            node.forEach((element) => {\n                let excalidrawElement;\n                switch (element.type) {\n                    case \"line\":\n                        excalidrawElement = transformToExcalidrawLineSkeleton(element);\n                        break;\n                    case \"rectangle\":\n                    case \"ellipse\":\n                        excalidrawElement = transformToExcalidrawContainerSkeleton(element);\n                        break;\n                    case \"text\":\n                        excalidrawElement = transformToExcalidrawTextSkeleton(element);\n                        break;\n                    default:\n                        throw `unknown type ${element.type}`;\n                        break;\n                }\n                if (element.type === \"rectangle\" && element?.subtype === \"activation\") {\n                    activations.push(excalidrawElement);\n                }\n                else {\n                    elements.push(excalidrawElement);\n                }\n            });\n        });\n        Object.values(chart.lines).forEach((line) => {\n            if (!line) {\n                return;\n            }\n            elements.push(transformToExcalidrawLineSkeleton(line));\n        });\n        Object.values(chart.arrows).forEach((arrow) => {\n            if (!arrow) {\n                return;\n            }\n            elements.push(transformToExcalidrawArrowSkeleton(arrow));\n            if (arrow.sequenceNumber) {\n                elements.push(transformToExcalidrawContainerSkeleton(arrow.sequenceNumber));\n            }\n        });\n        elements.push(...activations);\n        // loops\n        if (chart.loops) {\n            const { lines, texts, nodes } = chart.loops;\n            lines.forEach((line) => {\n                elements.push(transformToExcalidrawLineSkeleton(line));\n            });\n            texts.forEach((text) => {\n                elements.push(transformToExcalidrawTextSkeleton(text));\n            });\n            nodes.forEach((node) => {\n                elements.push(transformToExcalidrawContainerSkeleton(node));\n            });\n        }\n        if (chart.groups) {\n            chart.groups.forEach((group) => {\n                const { actorKeys, name } = group;\n                let minX = Infinity;\n                let minY = Infinity;\n                let maxX = 0;\n                let maxY = 0;\n                if (!actorKeys.length) {\n                    return;\n                }\n                const actors = elements.filter((ele) => {\n                    if (ele.id) {\n                        const hyphenIndex = ele.id.indexOf(\"-\");\n                        const id = ele.id.substring(0, hyphenIndex);\n                        return actorKeys.includes(id);\n                    }\n                });\n                actors.forEach((actor) => {\n                    if (actor.x === undefined ||\n                        actor.y === undefined ||\n                        actor.width === undefined ||\n                        actor.height === undefined) {\n                        throw new Error(`Actor attributes missing ${actor}`);\n                    }\n                    minX = Math.min(minX, actor.x);\n                    minY = Math.min(minY, actor.y);\n                    maxX = Math.max(maxX, actor.x + actor.width);\n                    maxY = Math.max(maxY, actor.y + actor.height);\n                });\n                // Draw the outer rectangle enclosing the group elements\n                const PADDING = 10;\n                const groupRectX = minX - PADDING;\n                const groupRectY = minY - PADDING;\n                const groupRectWidth = maxX - minX + PADDING * 2;\n                const groupRectHeight = maxY - minY + PADDING * 2;\n                const groupRectId = nanoid();\n                const groupRect = transformToExcalidrawContainerSkeleton({\n                    type: \"rectangle\",\n                    x: groupRectX,\n                    y: groupRectY,\n                    width: groupRectWidth,\n                    height: groupRectHeight,\n                    bgColor: group.fill,\n                    id: groupRectId,\n                });\n                elements.unshift(groupRect);\n                const frameId = nanoid();\n                const frameChildren = [groupRectId];\n                elements.forEach((ele) => {\n                    if (ele.type === \"frame\") {\n                        return;\n                    }\n                    if (ele.x === undefined ||\n                        ele.y === undefined ||\n                        ele.width === undefined ||\n                        ele.height === undefined) {\n                        throw new Error(`Element attributes missing ${ele}`);\n                    }\n                    if (ele.x >= minX &&\n                        ele.x + ele.width <= maxX &&\n                        ele.y >= minY &&\n                        ele.y + ele.height <= maxY) {\n                        const elementId = ele.id || nanoid();\n                        if (!ele.id) {\n                            Object.assign(ele, { id: elementId });\n                        }\n                        frameChildren.push(elementId);\n                    }\n                });\n                const frame = {\n                    type: \"frame\",\n                    id: frameId,\n                    name,\n                    children: frameChildren,\n                };\n                elements.push(frame);\n            });\n        }\n        return { elements };\n    },\n});\n", "import { nanoid } from \"nanoid\";\nimport { transformToExcalidrawArrowSkeleton, transformToExcalidrawContainerSkeleton, transformToExcalidrawLineSkeleton, transformToExcalidrawTextSkeleton, } from \"../transformToExcalidrawSkeleton.js\";\nimport { GraphConverter } from \"../GraphConverter.js\";\nexport const classToExcalidrawSkeletonConvertor = new GraphConverter({\n    converter: (chart) => {\n        const elements = [];\n        Object.values(chart.nodes).forEach((node) => {\n            if (!node || !node.length) {\n                return;\n            }\n            node.forEach((element) => {\n                let excalidrawElement;\n                switch (element.type) {\n                    case \"line\":\n                        excalidrawElement = transformToExcalidrawLineSkeleton(element);\n                        break;\n                    case \"rectangle\":\n                    case \"ellipse\":\n                        excalidrawElement = transformToExcalidrawContainerSkeleton(element);\n                        break;\n                    case \"text\":\n                        excalidrawElement = transformToExcalidrawTextSkeleton(element);\n                        break;\n                    default:\n                        throw `unknown type ${element.type}`;\n                        break;\n                }\n                elements.push(excalidrawElement);\n            });\n        });\n        Object.values(chart.lines).forEach((line) => {\n            if (!line) {\n                return;\n            }\n            elements.push(transformToExcalidrawLineSkeleton(line));\n        });\n        Object.values(chart.arrows).forEach((arrow) => {\n            if (!arrow) {\n                return;\n            }\n            const excalidrawElement = transformToExcalidrawArrowSkeleton(arrow);\n            elements.push(excalidrawElement);\n        });\n        Object.values(chart.text).forEach((ele) => {\n            const excalidrawElement = transformToExcalidrawTextSkeleton(ele);\n            elements.push(excalidrawElement);\n        });\n        Object.values(chart.namespaces).forEach((namespace) => {\n            const classIds = Object.keys(namespace.classes);\n            const children = [...classIds];\n            const chartElements = [...chart.lines, ...chart.arrows, ...chart.text];\n            classIds.forEach((classId) => {\n                const childIds = chartElements\n                    .filter((ele) => ele.metadata && ele.metadata.classId === classId)\n                    .map((ele) => ele.id);\n                if (childIds.length) {\n                    children.push(...childIds);\n                }\n            });\n            const frame = {\n                type: \"frame\",\n                id: nanoid(),\n                name: namespace.id,\n                children,\n            };\n            elements.push(frame);\n        });\n        return { elements };\n    },\n});\n", "import { FlowchartToExcalidrawSkeletonConverter } from \"./converter/types/flowchart.js\";\nimport { GraphImageConverter } from \"./converter/types/graphImage.js\";\nimport { SequenceToExcalidrawSkeletonConvertor } from \"./converter/types/sequence.js\";\nimport { classToExcalidrawSkeletonConvertor } from \"./converter/types/class.js\";\nexport const graphToExcalidraw = (graph, options = {}) => {\n    switch (graph.type) {\n        case \"graphImage\": {\n            return GraphImageConverter.convert(graph, options);\n        }\n        case \"flowchart\": {\n            return FlowchartToExcalidrawSkeletonConverter.convert(graph, options);\n        }\n        case \"sequence\": {\n            return SequenceToExcalidrawSkeletonConvertor.convert(graph, options);\n        }\n        case \"class\": {\n            return classToExcalidrawSkeletonConvertor.convert(graph, options);\n        }\n        default: {\n            throw new Error(`graphToExcalidraw: unknown graph type \"${graph.type}, only flowcharts are supported!\"`);\n        }\n    }\n};\n", "import \"ts-dedent\";\nimport { N } from \"./mermaid-b5860b54.js\";\nimport \"dayjs\";\nimport \"@braintree/sanitize-url\";\nimport \"d3\";\nimport \"dompurify\";\nimport \"khroma\";\nimport \"lodash-es/memoize.js\";\nimport \"lodash-es/merge.js\";\nimport \"stylis\";\nimport \"lodash-es/isEmpty.js\";\nexport {\n  N as default\n};\n", "// Convert mermaid entity codes to text e.g. \"#9829;\" to \"♥\"\nexport const entityCodesToText = (input) => {\n    input = decodeEntities(input);\n    // Append & before the pattern #(\\d+); or #([a-z]+); to convert to decimal code\n    // so it can be rendered as html character\n    // eg #9829; => &#9829;\n    const inputWithDecimalCode = input\n        .replace(/#(\\d+);/g, \"&#$1;\")\n        .replace(/#([a-z]+);/g, \"&$1;\");\n    // Render the decimal code as html character, eg &#9829; => ♥\n    const element = document.createElement(\"textarea\");\n    element.innerHTML = inputWithDecimalCode;\n    return element.value;\n};\nexport const getTransformAttr = (el) => {\n    const transformAttr = el.getAttribute(\"transform\");\n    const translateMatch = transformAttr?.match(/translate\\(([ \\d.-]+),\\s*([\\d.-]+)\\)/);\n    let transformX = 0;\n    let transformY = 0;\n    if (translateMatch) {\n        transformX = Number(translateMatch[1]);\n        transformY = Number(translateMatch[2]);\n    }\n    return { transformX, transformY };\n};\n//TODO Once fixed in mermaid this will be removed\nexport const encodeEntities = (text) => {\n    let txt = text;\n    txt = txt.replace(/style.*:\\S*#.*;/g, (s) => {\n        return s.substring(0, s.length - 1);\n    });\n    txt = txt.replace(/classDef.*:\\S*#.*;/g, (s) => {\n        return s.substring(0, s.length - 1);\n    });\n    txt = txt.replace(/#\\w+;/g, (s) => {\n        const innerTxt = s.substring(1, s.length - 1);\n        const isInt = /^\\+?\\d+$/.test(innerTxt);\n        if (isInt) {\n            return `ﬂ°°${innerTxt}¶ß`;\n        }\n        return `ﬂ°${innerTxt}¶ß`;\n    });\n    return txt;\n};\nexport const decodeEntities = function (text) {\n    return text.replace(/ﬂ°°/g, \"#\").replace(/ﬂ°/g, \"&\").replace(/¶ß/g, \";\");\n};\n// Compute edge postion start, end and points (reflection points)\nexport const computeEdgePositions = (pathElement, offset = { x: 0, y: 0 }) => {\n    // Check if the element is a path else throw an error\n    if (pathElement.tagName.toLowerCase() !== \"path\") {\n        throw new Error(`Invalid input: Expected an HTMLElement of tag \"path\", got ${pathElement.tagName}`);\n    }\n    // Get the d attribute from the path element else throw an error\n    const dAttr = pathElement.getAttribute(\"d\");\n    if (!dAttr) {\n        throw new Error('Path element does not contain a \"d\" attribute');\n    }\n    // Split the d attribute based on M (Move To) and L (Line To) commands\n    // eg \"M29.383,38.5L29.383,63.5L29.383,83.2\" => [\"M29.383,38.5\", \"L29.383,63.5\", \"L29.383,83.2\"]\n    const commands = dAttr.split(/(?=[LM])/);\n    // Get the start position from the first commands element => [29.383,38.5]\n    const startPosition = commands[0]\n        .substring(1)\n        .split(\",\")\n        .map((coord) => parseFloat(coord));\n    // Get the last position from the last commands element => [29.383,83.2]\n    const endPosition = commands[commands.length - 1]\n        .substring(1)\n        .split(\",\")\n        .map((coord) => parseFloat(coord));\n    // compute the reflection points -> [ {x: 29.383, y: 38.5}, {x: 29.383, y: 83.2} ]\n    // These includes the start and end points and also points which are not the same as the previous points\n    const reflectionPoints = commands\n        .map((command) => {\n        const coords = command\n            .substring(1)\n            .split(\",\")\n            .map((coord) => parseFloat(coord));\n        return { x: coords[0], y: coords[1] };\n    })\n        .filter((point, index, array) => {\n        // Always include the last point\n        if (index === 0 || index === array.length - 1) {\n            return true;\n        }\n        // Exclude the points which are the same as the previous point\n        if (point.x === array[index - 1].x && point.y === array[index - 1].y) {\n            return false;\n        }\n        // The below check is exclusively for second last point\n        if (index === array.length - 2 &&\n            (array[index - 1].x === point.x || array[index - 1].y === point.y)) {\n            const lastPoint = array[array.length - 1];\n            // Get the distance between the last point and second last point using Euclidean distance formula\n            const distance = Math.hypot(lastPoint.x - point.x, lastPoint.y - point.y);\n            // Include the second last point if the distance between the\n            // last point and second last point is > 20.\n            // This is to ensure we have a distance for render the edge.\n            // 20 seems to be a good enough distance to render the edge\n            return distance > 20;\n        }\n        // Always include if the current point is not the same as the previous point\n        return point.x !== array[index - 1].x || point.y !== array[index - 1].y;\n    })\n        .map((p) => {\n        // Offset the point by the provided offset\n        return {\n            x: p.x + offset.x,\n            y: p.y + offset.y,\n        };\n    });\n    // Return the edge positions\n    return {\n        startX: startPosition[0] + offset.x,\n        startY: startPosition[1] + offset.y,\n        endX: endPosition[0] + offset.x,\n        endY: endPosition[1] + offset.y,\n        reflectionPoints,\n    };\n};\n", "import { computeEdgePositions, entityCodesToText, getTransformAttr, } from \"../utils.js\";\nconst parseSubGraph = (data, containerEl) => {\n    // Extract only node id for better reference\n    // e.g. full element id = \"flowchart-c1-205\" will map to \"c1\"\n    const nodeIds = data.nodes.map((n) => {\n        if (n.startsWith(\"flowchart-\")) {\n            return n.split(\"-\")[1];\n        }\n        return n;\n    });\n    // Get position\n    const el = containerEl.querySelector(`[id='${data.id}']`);\n    if (!el) {\n        throw new Error(\"SubGraph element not found\");\n    }\n    const position = computeElementPosition(el, containerEl);\n    // Get dimension\n    const boundingBox = el.getBBox();\n    const dimension = {\n        width: boundingBox.width,\n        height: boundingBox.height,\n    };\n    // Remove irrelevant properties\n    data.classes = undefined;\n    data.dir = undefined;\n    return {\n        ...data,\n        nodeIds,\n        ...position,\n        ...dimension,\n        text: entityCodesToText(data.title),\n    };\n};\nconst parseVertex = (data, containerEl) => {\n    // Find Vertex element\n    const el = containerEl.querySelector(`[id*=\"flowchart-${data.id}-\"]`);\n    if (!el) {\n        return undefined;\n    }\n    // Check if Vertex attached with link\n    let link;\n    if (el.parentElement?.tagName.toLowerCase() === \"a\") {\n        link = el.parentElement.getAttribute(\"xlink:href\");\n    }\n    // Get position\n    const position = computeElementPosition(link ? el.parentElement : el, containerEl);\n    // Get dimension\n    const boundingBox = el.getBBox();\n    const dimension = {\n        width: boundingBox.width,\n        height: boundingBox.height,\n    };\n    // Extract style\n    const labelContainerStyleText = el\n        .querySelector(\".label-container\")\n        ?.getAttribute(\"style\");\n    const labelStyleText = el.querySelector(\".label\")?.getAttribute(\"style\");\n    const containerStyle = {};\n    labelContainerStyleText?.split(\";\").forEach((property) => {\n        if (!property) {\n            return;\n        }\n        const key = property.split(\":\")[0].trim();\n        const value = property.split(\":\")[1].trim();\n        containerStyle[key] = value;\n    });\n    const labelStyle = {};\n    labelStyleText?.split(\";\").forEach((property) => {\n        if (!property) {\n            return;\n        }\n        const key = property.split(\":\")[0].trim();\n        const value = property.split(\":\")[1].trim();\n        labelStyle[key] = value;\n    });\n    return {\n        id: data.id,\n        labelType: data.labelType,\n        text: entityCodesToText(data.text),\n        type: data.type,\n        link: link || undefined,\n        ...position,\n        ...dimension,\n        containerStyle,\n        labelStyle,\n    };\n};\nconst parseEdge = (data, edgeIndex, containerEl) => {\n    // Find edge element\n    const edge = containerEl.querySelector(`[id*=\"L-${data.start}-${data.end}-${edgeIndex}\"]`);\n    if (!edge) {\n        throw new Error(\"Edge element not found\");\n    }\n    // Compute edge position data\n    const position = computeElementPosition(edge, containerEl);\n    const edgePositionData = computeEdgePositions(edge, position);\n    // Remove irrelevant properties\n    data.length = undefined;\n    return {\n        ...data,\n        ...edgePositionData,\n        text: entityCodesToText(data.text),\n    };\n};\n// Compute element position\nconst computeElementPosition = (el, containerEl) => {\n    if (!el) {\n        throw new Error(\"Element not found\");\n    }\n    let root = el.parentElement?.parentElement;\n    const childElement = el.childNodes[0];\n    let childPosition = { x: 0, y: 0 };\n    if (childElement) {\n        const { transformX, transformY } = getTransformAttr(childElement);\n        const boundingBox = childElement.getBBox();\n        childPosition = {\n            x: Number(childElement.getAttribute(\"x\")) ||\n                transformX + boundingBox.x ||\n                0,\n            y: Number(childElement.getAttribute(\"y\")) ||\n                transformY + boundingBox.y ||\n                0,\n        };\n    }\n    const { transformX, transformY } = getTransformAttr(el);\n    const position = {\n        x: transformX + childPosition.x,\n        y: transformY + childPosition.y,\n    };\n    while (root && root.id !== containerEl.id) {\n        if (root.classList.value === \"root\" && root.hasAttribute(\"transform\")) {\n            const { transformX, transformY } = getTransformAttr(root);\n            position.x += transformX;\n            position.y += transformY;\n        }\n        root = root.parentElement;\n    }\n    return position;\n};\nexport const parseMermaidFlowChartDiagram = (diagram, containerEl) => {\n    // This does some cleanup and initialization making sure\n    // diagram is parsed correctly. Useful when multiple diagrams are\n    // parsed together one after another, eg in playground\n    // https://github.com/mermaid-js/mermaid/blob/e561cbd3be2a93b8bedfa4839484966faad92ccf/packages/mermaid/src/Diagram.ts#L43\n    diagram.parse();\n    // Get mermaid parsed data from parser shared variable `yy`\n    //@ts-ignore\n    const mermaidParser = diagram.parser.yy;\n    const vertices = mermaidParser.getVertices();\n    Object.keys(vertices).forEach((id) => {\n        vertices[id] = parseVertex(vertices[id], containerEl);\n    });\n    // Track the count of edges based on the edge id\n    const edgeCountMap = new Map();\n    const edges = mermaidParser\n        .getEdges()\n        .filter((edge) => {\n        // Sometimes mermaid parser returns edges which are not present in the DOM hence this is a safety check to only consider edges present in the DOM, issue - https://github.com/mermaid-js/mermaid/issues/5516\n        return containerEl.querySelector(`[id*=\"L-${edge.start}-${edge.end}\"]`);\n    })\n        .map((data) => {\n        const edgeId = `${data.start}-${data.end}`;\n        const count = edgeCountMap.get(edgeId) || 0;\n        edgeCountMap.set(edgeId, count + 1);\n        return parseEdge(data, count, containerEl);\n    });\n    const subGraphs = mermaidParser\n        .getSubGraphs()\n        .map((data) => parseSubGraph(data, containerEl));\n    return {\n        type: \"flowchart\",\n        subGraphs,\n        vertices,\n        edges,\n    };\n};\n", "import { entityCodesToText } from \"./utils.js\";\nimport { DEFAULT_FONT_SIZE } from \"./constants.js\";\nexport const createArrowSkeletonFromSVG = (arrowNode, opts) => {\n    const arrow = {};\n    if (opts?.label) {\n        arrow.label = { text: entityCodesToText(opts.label), fontSize: 16 };\n    }\n    const tagName = arrowNode.tagName;\n    if (tagName === \"line\") {\n        arrow.startX = Number(arrowNode.getAttribute(\"x1\"));\n        arrow.startY = Number(arrowNode.getAttribute(\"y1\"));\n        arrow.endX = Number(arrowNode.getAttribute(\"x2\"));\n        arrow.endY = Number(arrowNode.getAttribute(\"y2\"));\n    }\n    else if (tagName === \"path\") {\n        const dAttr = arrowNode.getAttribute(\"d\");\n        if (!dAttr) {\n            throw new Error('Path element does not contain a \"d\" attribute');\n        }\n        // Split the d attribute based on M (Move To)  and C (Curve) commands\n        const commands = dAttr.split(/(?=[LC])/);\n        const startPosition = commands[0]\n            .substring(1)\n            .split(\",\")\n            .map((coord) => parseFloat(coord));\n        const points = [];\n        commands.forEach((command) => {\n            const currPoints = command\n                .substring(1)\n                .trim()\n                .split(\" \")\n                .map((pos) => {\n                const [x, y] = pos.split(\",\");\n                return [\n                    parseFloat(x) - startPosition[0],\n                    parseFloat(y) - startPosition[1],\n                ];\n            });\n            points.push(...currPoints);\n        });\n        const endPosition = points[points.length - 1];\n        arrow.startX = startPosition[0];\n        arrow.startY = startPosition[1];\n        arrow.endX = endPosition[0];\n        arrow.endY = endPosition[1];\n        arrow.points = points;\n    }\n    if (opts?.label) {\n        // In mermaid the text is positioned above arrow but in Excalidraw\n        // its postioned on the arrow hence the elements below it might look cluttered so shifting the arrow by an offset of 10px\n        const offset = 10;\n        arrow.startY = arrow.startY - offset;\n        arrow.endY = arrow.endY - offset;\n    }\n    arrow.strokeColor = arrowNode.getAttribute(\"stroke\");\n    arrow.strokeWidth = Number(arrowNode.getAttribute(\"stroke-width\"));\n    arrow.type = \"arrow\";\n    arrow.strokeStyle = opts?.strokeStyle || \"solid\";\n    arrow.startArrowhead = opts?.startArrowhead || null;\n    arrow.endArrowhead = opts?.endArrowhead || null;\n    return arrow;\n};\nexport const createArrowSkeletion = (startX, startY, endX, endY, opts) => {\n    const arrow = {};\n    arrow.type = \"arrow\";\n    arrow.startX = startX;\n    arrow.startY = startY;\n    arrow.endX = endX;\n    arrow.endY = endY;\n    Object.assign(arrow, { ...opts });\n    return arrow;\n};\nexport const createTextSkeleton = (x, y, text, opts) => {\n    const textElement = {\n        type: \"text\",\n        x,\n        y,\n        text,\n        width: opts?.width || 20,\n        height: opts?.height || 20,\n        fontSize: opts?.fontSize || DEFAULT_FONT_SIZE,\n        id: opts?.id,\n        groupId: opts?.groupId,\n        metadata: opts?.metadata,\n    };\n    return textElement;\n};\nexport const createTextSkeletonFromSVG = (textNode, text, opts) => {\n    const node = {};\n    const x = Number(textNode.getAttribute(\"x\"));\n    const y = Number(textNode.getAttribute(\"y\"));\n    node.type = \"text\";\n    node.text = entityCodesToText(text);\n    if (opts?.id) {\n        node.id = opts.id;\n    }\n    if (opts?.groupId) {\n        node.groupId = opts.groupId;\n    }\n    const boundingBox = textNode.getBBox();\n    node.width = boundingBox.width;\n    node.height = boundingBox.height;\n    node.x = x - boundingBox.width / 2;\n    node.y = y;\n    const fontSize = parseInt(getComputedStyle(textNode).fontSize);\n    node.fontSize = fontSize;\n    return node;\n};\nexport const createContainerSkeletonFromSVG = (node, type, opts = {}) => {\n    const container = {};\n    container.type = type;\n    const { label, subtype, id, groupId } = opts;\n    container.id = id;\n    if (groupId) {\n        container.groupId = groupId;\n    }\n    if (label) {\n        container.label = {\n            text: entityCodesToText(label.text),\n            fontSize: 16,\n            verticalAlign: label?.verticalAlign,\n        };\n    }\n    const boundingBox = node.getBBox();\n    container.x = boundingBox.x;\n    container.y = boundingBox.y;\n    container.width = boundingBox.width;\n    container.height = boundingBox.height;\n    container.subtype = subtype;\n    switch (subtype) {\n        case \"highlight\":\n            const bgColor = node.getAttribute(\"fill\");\n            if (bgColor) {\n                container.bgColor = bgColor;\n            }\n            break;\n        case \"note\":\n            container.strokeStyle = \"dashed\";\n            break;\n    }\n    return container;\n};\nexport const createLineSkeletonFromSVG = (lineNode, startX, startY, endX, endY, opts) => {\n    const line = {};\n    line.startX = startX;\n    line.startY = startY;\n    line.endX = endX;\n    if (opts?.groupId) {\n        line.groupId = opts.groupId;\n    }\n    if (opts?.id) {\n        line.id = opts.id;\n    }\n    // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n    line.endY = endY;\n    line.strokeColor = lineNode.getAttribute(\"stroke\");\n    line.strokeWidth = Number(lineNode.getAttribute(\"stroke-width\"));\n    line.type = \"line\";\n    return line;\n};\n", "import { SVG_TO_SHAPE_MAPPER } from \"../constants.js\";\nimport { nanoid } from \"nanoid\";\nimport { createArrowSkeletonFromSVG, createContainerSkeletonFromSVG, createLineSkeletonFromSVG, createTextSkeletonFromSVG, } from \"../elementSkeleton.js\";\n// Currently mermaid supported these 6 arrow types, the names are taken from mermaidParser.LINETYPE\nconst SEQUENCE_ARROW_TYPES = {\n    0: \"SOLID\",\n    1: \"DOTTED\",\n    3: \"SOLID_CROSS\",\n    4: \"DOTTED_CROSS\",\n    5: \"SOLID_OPEN\",\n    6: \"DOTTED_OPEN\",\n    24: \"SOLID_POINT\",\n    25: \"DOTTED_POINT\",\n};\nconst MESSAGE_TYPE = {\n    SOLID: 0,\n    DOTTED: 1,\n    NOTE: 2,\n    SOLID_CROSS: 3,\n    DOTTED_CROSS: 4,\n    SOLID_OPEN: 5,\n    DOTTED_OPEN: 6,\n    LOOP_START: 10,\n    LOOP_END: 11,\n    ALT_START: 12,\n    ALT_ELSE: 13,\n    ALT_END: 14,\n    OPT_START: 15,\n    OPT_END: 16,\n    ACTIVE_START: 17,\n    ACTIVE_END: 18,\n    PAR_START: 19,\n    PAR_AND: 20,\n    PAR_END: 21,\n    RECT_START: 22,\n    RECT_END: 23,\n    SOLID_POINT: 24,\n    DOTTED_POINT: 25,\n    AUTONUMBER: 26,\n    CRITICAL_START: 27,\n    CRITICAL_OPTION: 28,\n    CRITICAL_END: 29,\n    BREAK_START: 30,\n    BREAK_END: 31,\n    PAR_OVER_START: 32,\n};\nconst getStrokeStyle = (type) => {\n    let strokeStyle;\n    switch (type) {\n        case MESSAGE_TYPE.SOLID:\n        case MESSAGE_TYPE.SOLID_CROSS:\n        case MESSAGE_TYPE.SOLID_OPEN:\n        case MESSAGE_TYPE.SOLID_POINT:\n            strokeStyle = \"solid\";\n            break;\n        case MESSAGE_TYPE.DOTTED:\n        case MESSAGE_TYPE.DOTTED_CROSS:\n        case MESSAGE_TYPE.DOTTED_OPEN:\n        case MESSAGE_TYPE.DOTTED_POINT:\n            strokeStyle = \"dotted\";\n            break;\n        default:\n            strokeStyle = \"solid\";\n            break;\n    }\n    return strokeStyle;\n};\nconst attachSequenceNumberToArrow = (node, arrow) => {\n    const showSequenceNumber = !!node.nextElementSibling?.classList.contains(\"sequenceNumber\");\n    if (showSequenceNumber) {\n        const text = node.nextElementSibling?.textContent;\n        if (!text) {\n            throw new Error(\"sequence number not present\");\n        }\n        const height = 30;\n        const yOffset = height / 2;\n        const xOffset = 10;\n        const sequenceNumber = {\n            type: \"rectangle\",\n            x: arrow.startX - xOffset,\n            y: arrow.startY - yOffset,\n            label: { text, fontSize: 14 },\n            bgColor: \"#e9ecef\",\n            height,\n            subtype: \"sequence\",\n        };\n        Object.assign(arrow, { sequenceNumber });\n    }\n};\nconst createActorSymbol = (rootNode, text, opts) => {\n    if (!rootNode) {\n        throw \"root node not found\";\n    }\n    const groupId = nanoid();\n    const children = Array.from(rootNode.children);\n    const nodeElements = [];\n    children.forEach((child, index) => {\n        const id = `${opts?.id}-${index}`;\n        let ele;\n        switch (child.tagName) {\n            case \"line\":\n                const startX = Number(child.getAttribute(\"x1\"));\n                const startY = Number(child.getAttribute(\"y1\"));\n                const endX = Number(child.getAttribute(\"x2\"));\n                const endY = Number(child.getAttribute(\"y2\"));\n                ele = createLineSkeletonFromSVG(child, startX, startY, endX, endY, { groupId, id });\n                break;\n            case \"text\":\n                ele = createTextSkeletonFromSVG(child, text, {\n                    groupId,\n                    id,\n                });\n                break;\n            case \"circle\":\n                ele = createContainerSkeletonFromSVG(child, \"ellipse\", {\n                    label: child.textContent ? { text: child.textContent } : undefined,\n                    groupId,\n                    id,\n                });\n            default:\n                ele = createContainerSkeletonFromSVG(child, SVG_TO_SHAPE_MAPPER[child.tagName], {\n                    label: child.textContent ? { text: child.textContent } : undefined,\n                    groupId,\n                    id,\n                });\n        }\n        nodeElements.push(ele);\n    });\n    return nodeElements;\n};\nconst parseActor = (actors, containerEl) => {\n    const actorTopNodes = Array.from(containerEl.querySelectorAll(\".actor-top\"));\n    const actorBottomNodes = Array.from(containerEl.querySelectorAll(\".actor-bottom\"));\n    const nodes = [];\n    const lines = [];\n    Object.values(actors).forEach((actor, index) => {\n        const topRootNode = actorTopNodes.find((actorNode) => actorNode.getAttribute(\"name\") === actor.name);\n        const bottomRootNode = actorBottomNodes.find((actorNode) => actorNode.getAttribute(\"name\") === actor.name);\n        if (!topRootNode || !bottomRootNode) {\n            throw \"root not found\";\n        }\n        const text = actor.description;\n        if (actor.type === \"participant\") {\n            // creating top actor node element\n            const topNodeElement = createContainerSkeletonFromSVG(topRootNode, \"rectangle\", { id: `${actor.name}-top`, label: { text }, subtype: \"actor\" });\n            if (!topNodeElement) {\n                throw \"Top Node element not found!\";\n            }\n            nodes.push([topNodeElement]);\n            // creating bottom actor node element\n            const bottomNodeElement = createContainerSkeletonFromSVG(bottomRootNode, \"rectangle\", { id: `${actor.name}-bottom`, label: { text }, subtype: \"actor\" });\n            nodes.push([bottomNodeElement]);\n            // Get the line connecting the top and bottom nodes. As per the DOM, the line is rendered as sibling parent of top root node\n            const lineNode = topRootNode?.parentElement\n                ?.previousElementSibling;\n            if (lineNode?.tagName !== \"line\") {\n                throw \"Line not found\";\n            }\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            if (!topNodeElement.height) {\n                throw \"Top node element height is null\";\n            }\n            const startY = topNodeElement.y + topNodeElement.height;\n            // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n            const endY = bottomNodeElement.y;\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY);\n            lines.push(line);\n        }\n        else if (actor.type === \"actor\") {\n            const topNodeElement = createActorSymbol(topRootNode, text, {\n                id: `${actor.name}-top`,\n            });\n            nodes.push(topNodeElement);\n            const bottomNodeElement = createActorSymbol(bottomRootNode, text, {\n                id: `${actor.name}-bottom`,\n            });\n            nodes.push(bottomNodeElement);\n            // Get the line connecting the top and bottom nodes. As per the DOM, the line is rendered as sibling of the actor root element\n            const lineNode = topRootNode.previousElementSibling;\n            if (lineNode?.tagName !== \"line\") {\n                throw \"Line not found\";\n            }\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            const startY = Number(lineNode.getAttribute(\"y1\"));\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            // Make sure lines don't overlap with the nodes, in mermaid it overlaps but isn't visible as its pushed back and containers are non transparent\n            const bottomEllipseNode = bottomNodeElement.find((node) => node.type === \"ellipse\");\n            if (bottomEllipseNode) {\n                const endY = bottomEllipseNode.y;\n                const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY);\n                lines.push(line);\n            }\n        }\n    });\n    return { nodes, lines };\n};\nconst computeArrows = (messages, containerEl) => {\n    const arrows = [];\n    const arrowNodes = Array.from(containerEl.querySelectorAll('[class*=\"messageLine\"]'));\n    const supportedMessageTypes = Object.keys(SEQUENCE_ARROW_TYPES);\n    const arrowMessages = messages.filter((message) => supportedMessageTypes.includes(message.type.toString()));\n    arrowNodes.forEach((arrowNode, index) => {\n        const message = arrowMessages[index];\n        const messageType = SEQUENCE_ARROW_TYPES[message.type];\n        const arrow = createArrowSkeletonFromSVG(arrowNode, {\n            label: message?.message,\n            strokeStyle: getStrokeStyle(message.type),\n            endArrowhead: messageType === \"SOLID_OPEN\" || messageType === \"DOTTED_OPEN\"\n                ? null\n                : \"arrow\",\n        });\n        attachSequenceNumberToArrow(arrowNode, arrow);\n        arrows.push(arrow);\n    });\n    return arrows;\n};\nconst computeNotes = (messages, containerEl) => {\n    const noteNodes = Array.from(containerEl.querySelectorAll(\".note\")).map((node) => node.parentElement);\n    const noteText = messages.filter((message) => message.type === MESSAGE_TYPE.NOTE);\n    const notes = [];\n    noteNodes.forEach((node, index) => {\n        if (!node) {\n            return;\n        }\n        const rect = node.firstChild;\n        const text = noteText[index].message;\n        const note = createContainerSkeletonFromSVG(rect, \"rectangle\", {\n            label: { text },\n            subtype: \"note\",\n        });\n        notes.push(note);\n    });\n    return notes;\n};\nconst parseActivations = (containerEl) => {\n    const activationNodes = Array.from(containerEl.querySelectorAll(`[class*=activation]`));\n    const activations = [];\n    activationNodes.forEach((node) => {\n        const rect = createContainerSkeletonFromSVG(node, \"rectangle\", {\n            label: { text: \"\" },\n            subtype: \"activation\",\n        });\n        activations.push(rect);\n    });\n    return activations;\n};\nconst parseLoops = (messages, containerEl) => {\n    const lineNodes = Array.from(containerEl.querySelectorAll(\".loopLine\"));\n    const lines = [];\n    const texts = [];\n    const nodes = [];\n    lineNodes.forEach((node) => {\n        const startX = Number(node.getAttribute(\"x1\"));\n        const startY = Number(node.getAttribute(\"y1\"));\n        const endX = Number(node.getAttribute(\"x2\"));\n        const endY = Number(node.getAttribute(\"y2\"));\n        const line = createLineSkeletonFromSVG(node, startX, startY, endX, endY);\n        line.strokeStyle = \"dotted\";\n        line.strokeColor = \"#adb5bd\";\n        line.strokeWidth = 2;\n        lines.push(line);\n    });\n    const loopTextNodes = Array.from(containerEl.querySelectorAll(\".loopText\"));\n    const criticalMessages = messages\n        .filter((message) => message.type === MESSAGE_TYPE.CRITICAL_START)\n        .map((message) => message.message);\n    loopTextNodes.forEach((node) => {\n        const text = node.textContent || \"\";\n        const textElement = createTextSkeletonFromSVG(node, text);\n        // The text is rendered between [ ] in DOM hence getting the text excluding the [ ]\n        const rawText = text.match(/\\[(.*?)\\]/)?.[1] || \"\";\n        const isCritical = criticalMessages.includes(rawText);\n        // For critical label the coordinates are not accurate in mermaid as there is\n        // no padding left hence shifting the text next to critical label by 16px (font size)\n        if (isCritical) {\n            textElement.x += 16;\n        }\n        texts.push(textElement);\n    });\n    const labelBoxes = Array.from(containerEl?.querySelectorAll(\".labelBox\"));\n    const labelTextNode = Array.from(containerEl?.querySelectorAll(\".labelText\"));\n    labelBoxes.forEach((labelBox, index) => {\n        const text = labelTextNode[index]?.textContent || \"\";\n        const container = createContainerSkeletonFromSVG(labelBox, \"rectangle\", {\n            label: { text },\n        });\n        container.strokeColor = \"#adb5bd\";\n        container.bgColor = \"#e9ecef\";\n        // So width is calculated based on label\n        container.width = undefined;\n        nodes.push(container);\n    });\n    return { lines, texts, nodes };\n};\nconst computeHighlights = (containerEl) => {\n    const rects = Array.from(containerEl.querySelectorAll(\".rect\"))\n        // Only drawing specifically for highlights as the same selector is for grouping as well. For grouping we\n        // draw it ourselves\n        .filter((node) => node.parentElement?.tagName !== \"g\");\n    const nodes = [];\n    rects.forEach((rect) => {\n        const node = createContainerSkeletonFromSVG(rect, \"rectangle\", {\n            label: { text: \"\" },\n            subtype: \"highlight\",\n        });\n        nodes.push(node);\n    });\n    return nodes;\n};\nexport const parseMermaidSequenceDiagram = (diagram, containerEl) => {\n    diagram.parse();\n    // Get mermaid parsed data from parser shared variable `yy`\n    //@ts-ignore\n    const mermaidParser = diagram.parser.yy;\n    const nodes = [];\n    const groups = mermaidParser.getBoxes();\n    const bgHightlights = computeHighlights(containerEl);\n    const actorData = mermaidParser.getActors();\n    const { nodes: actors, lines } = parseActor(actorData, containerEl);\n    const messages = mermaidParser.getMessages();\n    const arrows = computeArrows(messages, containerEl);\n    const notes = computeNotes(messages, containerEl);\n    const activations = parseActivations(containerEl);\n    const loops = parseLoops(messages, containerEl);\n    nodes.push(bgHightlights);\n    nodes.push(...actors);\n    nodes.push(notes);\n    nodes.push(activations);\n    return { type: \"sequence\", lines, arrows, nodes, loops, groups };\n};\n", "import { nanoid } from \"nanoid\";\nimport { computeEdgePositions, getTransformAttr } from \"../utils.js\";\nimport { createArrowSkeletion, createContainerSkeletonFromSVG, createLineSkeletonFromSVG, createTextSkeleton, } from \"../elementSkeleton.js\";\n// Taken from mermaidParser.relationType\nconst RELATION_TYPE = {\n    AGGREGATION: 0,\n    EXTENSION: 1,\n    COMPOSITION: 2,\n    DEPENDENCY: 3,\n    LOLLIPOP: 4,\n};\n// Taken from mermaidParser.lineType\nconst LINE_TYPE = {\n    LINE: 0,\n    DOTTED_LINE: 1,\n};\n// This is the offset to update the arrow head postition for rendering in excalidraw as mermaid calculates the position until the start of arrowhead\nconst MERMAID_ARROW_HEAD_OFFSET = 16;\nconst getStrokeStyle = (type) => {\n    let lineType;\n    switch (type) {\n        case LINE_TYPE.LINE:\n            lineType = \"solid\";\n            break;\n        case LINE_TYPE.DOTTED_LINE:\n            lineType = \"dotted\";\n            break;\n        default:\n            lineType = \"solid\";\n    }\n    return lineType;\n};\nconst getArrowhead = (type) => {\n    let arrowhead;\n    switch (type) {\n        case RELATION_TYPE.AGGREGATION:\n            arrowhead = \"diamond_outline\";\n            break;\n        case RELATION_TYPE.COMPOSITION:\n            arrowhead = \"diamond\";\n            break;\n        case RELATION_TYPE.EXTENSION:\n            arrowhead = \"triangle_outline\";\n            break;\n        case \"none\":\n            arrowhead = null;\n            break;\n        case RELATION_TYPE.DEPENDENCY:\n        default:\n            arrowhead = \"arrow\";\n            break;\n    }\n    return arrowhead;\n};\nconst parseClasses = (classes, containerEl) => {\n    const nodes = [];\n    const lines = [];\n    const text = [];\n    Object.values(classes).forEach((classNode) => {\n        const { domId, id: classId } = classNode;\n        const groupId = nanoid();\n        const domNode = containerEl.querySelector(`[data-id=${classId}]`);\n        if (!domNode) {\n            throw Error(`DOM Node with id ${domId} not found`);\n        }\n        const { transformX, transformY } = getTransformAttr(domNode);\n        const container = createContainerSkeletonFromSVG(domNode.firstChild, \"rectangle\", { id: classId, groupId });\n        container.x += transformX;\n        container.y += transformY;\n        container.metadata = { classId };\n        nodes.push(container);\n        const lineNodes = Array.from(domNode.querySelectorAll(\".divider\"));\n        lineNodes.forEach((lineNode) => {\n            const startX = Number(lineNode.getAttribute(\"x1\"));\n            const startY = Number(lineNode.getAttribute(\"y1\"));\n            const endX = Number(lineNode.getAttribute(\"x2\"));\n            const endY = Number(lineNode.getAttribute(\"y2\"));\n            const line = createLineSkeletonFromSVG(lineNode, startX, startY, endX, endY, {\n                groupId,\n                id: nanoid(),\n            });\n            line.startX += transformX;\n            line.startY += transformY;\n            line.endX += transformX;\n            line.endY += transformY;\n            line.metadata = { classId };\n            lines.push(line);\n        });\n        const labelNodes = domNode.querySelector(\".label\")?.children;\n        if (!labelNodes) {\n            throw \"label nodes not found\";\n        }\n        Array.from(labelNodes).forEach((node) => {\n            const label = node.textContent;\n            if (!label) {\n                return;\n            }\n            const id = nanoid();\n            const { transformX: textTransformX, transformY: textTransformY } = getTransformAttr(node);\n            const boundingBox = node.getBBox();\n            const offsetY = 10;\n            const textElement = createTextSkeleton(transformX + textTransformX, transformY + textTransformY + offsetY, label, {\n                width: boundingBox.width,\n                height: boundingBox.height,\n                id,\n                groupId,\n                metadata: { classId },\n            });\n            text.push(textElement);\n        });\n    });\n    return { nodes, lines, text };\n};\n// update arrow position by certain offset for triangle and diamond arrow head types\n// as mermaid calculates the position until the start of arrowhead\n// for reference - https://github.com/mermaid-js/mermaid/issues/5417\nconst adjustArrowPosition = (direction, arrow) => {\n    // The arrowhead shapes where we need to update the position by a 16px offset\n    const arrowHeadShapes = [\"triangle_outline\", \"diamond\", \"diamond_outline\"];\n    const shouldUpdateStartArrowhead = arrow.startArrowhead && arrowHeadShapes.includes(arrow.startArrowhead);\n    const shouldUpdateEndArrowhead = arrow.endArrowhead && arrowHeadShapes.includes(arrow.endArrowhead);\n    if (!shouldUpdateEndArrowhead && !shouldUpdateStartArrowhead) {\n        return arrow;\n    }\n    if (shouldUpdateStartArrowhead) {\n        if (direction === \"LR\") {\n            arrow.startX -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"RL\") {\n            arrow.startX += MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"TB\") {\n            arrow.startY -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"BT\") {\n            arrow.startY += MERMAID_ARROW_HEAD_OFFSET;\n        }\n    }\n    if (shouldUpdateEndArrowhead) {\n        if (direction === \"LR\") {\n            arrow.endX += MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"RL\") {\n            arrow.endX -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"TB\") {\n            arrow.endY += MERMAID_ARROW_HEAD_OFFSET;\n        }\n        else if (direction === \"BT\") {\n            arrow.endY -= MERMAID_ARROW_HEAD_OFFSET;\n        }\n    }\n    return arrow;\n};\nconst parseRelations = (relations, classNodes, containerEl, direction) => {\n    const edges = containerEl.querySelector(\".edgePaths\")?.children;\n    if (!edges) {\n        throw new Error(\"No Edges found!\");\n    }\n    const arrows = [];\n    const text = [];\n    relations.forEach((relationNode, index) => {\n        const { id1, id2, relation } = relationNode;\n        const node1 = classNodes.find((node) => node.id === id1);\n        const node2 = classNodes.find((node) => node.id === id2);\n        const strokeStyle = getStrokeStyle(relation.lineType);\n        const startArrowhead = getArrowhead(relation.type1);\n        const endArrowhead = getArrowhead(relation.type2);\n        const edgePositionData = computeEdgePositions(edges[index]);\n        const arrowSkeletion = createArrowSkeletion(edgePositionData.startX, edgePositionData.startY, edgePositionData.endX, edgePositionData.endY, {\n            strokeStyle,\n            startArrowhead,\n            endArrowhead,\n            label: relationNode.title ? { text: relationNode.title } : undefined,\n            start: { type: \"rectangle\", id: node1.id },\n            end: { type: \"rectangle\", id: node2.id },\n        });\n        const arrow = adjustArrowPosition(direction, arrowSkeletion);\n        arrows.push(arrow);\n        // Add cardianlities and Multiplicities\n        const { relationTitle1, relationTitle2 } = relationNode;\n        const offsetX = 20;\n        const offsetY = 15;\n        const directionOffset = 15;\n        let x;\n        let y;\n        if (relationTitle1 && relationTitle1 !== \"none\") {\n            switch (direction) {\n                case \"TB\":\n                    x = arrow.startX - offsetX;\n                    if (arrow.endX < arrow.startX) {\n                        x -= directionOffset;\n                    }\n                    y = arrow.startY + offsetY;\n                    break;\n                case \"BT\":\n                    x = arrow.startX + offsetX;\n                    if (arrow.endX > arrow.startX) {\n                        x += directionOffset;\n                    }\n                    y = arrow.startY - offsetY;\n                    break;\n                case \"LR\":\n                    x = arrow.startX + offsetX;\n                    y = arrow.startY + offsetY;\n                    if (arrow.endY > arrow.startY) {\n                        y += directionOffset;\n                    }\n                    break;\n                case \"RL\":\n                    x = arrow.startX - offsetX;\n                    y = arrow.startY - offsetY;\n                    if (arrow.startY > arrow.endY) {\n                        y -= directionOffset;\n                    }\n                    break;\n                default:\n                    x = arrow.startX - offsetX;\n                    y = arrow.startY + offsetY;\n            }\n            const relationTitleElement = createTextSkeleton(x, y, relationTitle1, {\n                fontSize: 16,\n            });\n            text.push(relationTitleElement);\n        }\n        if (relationTitle2 && relationTitle2 !== \"none\") {\n            switch (direction) {\n                case \"TB\":\n                    x = arrow.endX + offsetX;\n                    if (arrow.endX < arrow.startX) {\n                        x += directionOffset;\n                    }\n                    y = arrow.endY - offsetY;\n                    break;\n                case \"BT\":\n                    x = arrow.endX - offsetX;\n                    if (arrow.endX > arrow.startX) {\n                        x -= directionOffset;\n                    }\n                    y = arrow.endY + offsetY;\n                    break;\n                case \"LR\":\n                    x = arrow.endX - offsetX;\n                    y = arrow.endY - offsetY;\n                    if (arrow.endY > arrow.startY) {\n                        y -= directionOffset;\n                    }\n                    break;\n                case \"RL\":\n                    x = arrow.endX + offsetX;\n                    y = arrow.endY + offsetY;\n                    if (arrow.startY > arrow.endY) {\n                        y += directionOffset;\n                    }\n                    break;\n                default:\n                    x = arrow.endX + offsetX;\n                    y = arrow.endY - offsetY;\n            }\n            const relationTitleElement = createTextSkeleton(x, y, relationTitle2, {\n                fontSize: 16,\n            });\n            text.push(relationTitleElement);\n        }\n    });\n    return { arrows, text };\n};\nconst parseNotes = (notes, containerEl, classNodes) => {\n    const noteContainers = [];\n    const connectors = [];\n    notes.forEach((note) => {\n        const { id, text, class: classId } = note;\n        const node = containerEl.querySelector(`#${id}`);\n        if (!node) {\n            throw new Error(`Node with id ${id} not found!`);\n        }\n        const { transformX, transformY } = getTransformAttr(node);\n        const rect = node.firstChild;\n        const container = createContainerSkeletonFromSVG(rect, \"rectangle\", {\n            id,\n            subtype: \"note\",\n            label: { text },\n        });\n        Object.assign(container, {\n            x: container.x + transformX,\n            y: container.y + transformY,\n        });\n        noteContainers.push(container);\n        if (classId) {\n            const classNode = classNodes.find((node) => node.id === classId);\n            if (!classNode) {\n                throw new Error(`class node with id ${classId} not found!`);\n            }\n            const startX = container.x + (container.width || 0) / 2;\n            const startY = container.y + (container.height || 0);\n            const endX = startX;\n            const endY = classNode.y;\n            const connector = createArrowSkeletion(startX, startY, endX, endY, {\n                strokeStyle: \"dotted\",\n                startArrowhead: null,\n                endArrowhead: null,\n                start: { id: container.id, type: \"rectangle\" },\n                end: { id: classNode.id, type: \"rectangle\" },\n            });\n            connectors.push(connector);\n        }\n    });\n    return { notes: noteContainers, connectors };\n};\nexport const parseMermaidClassDiagram = (diagram, containerEl) => {\n    diagram.parse();\n    //@ts-ignore\n    const mermaidParser = diagram.parser.yy;\n    const direction = mermaidParser.getDirection();\n    const nodes = [];\n    const lines = [];\n    const text = [];\n    const classNodes = [];\n    const namespaces = mermaidParser.getNamespaces();\n    const classes = mermaidParser.getClasses();\n    if (Object.keys(classes).length) {\n        const classData = parseClasses(classes, containerEl);\n        nodes.push(classData.nodes);\n        lines.push(...classData.lines);\n        text.push(...classData.text);\n        classNodes.push(...classData.nodes);\n    }\n    const relations = mermaidParser.getRelations();\n    const { arrows, text: relationTitles } = parseRelations(relations, classNodes, containerEl, direction);\n    const { notes, connectors } = parseNotes(mermaidParser.getNotes(), containerEl, classNodes);\n    nodes.push(notes);\n    arrows.push(...connectors);\n    text.push(...relationTitles);\n    return { type: \"class\", nodes, lines, arrows, text, namespaces };\n};\n", "import mermaid from \"mermaid\";\nimport { MERMAID_CONFIG } from \"./constants.js\";\nimport { encodeEntities } from \"./utils.js\";\nimport { parseMermaidFlowChartDiagram } from \"./parser/flowchart.js\";\nimport { parseMermaidSequenceDiagram } from \"./parser/sequence.js\";\nimport { parseMermaidClassDiagram } from \"./parser/class.js\";\n// Fallback to Svg\nconst convertSvgToGraphImage = (svgContainer) => {\n    // Extract SVG width and height\n    // TODO: make width and height change dynamically based on user's screen dimension\n    const svgEl = svgContainer.querySelector(\"svg\");\n    if (!svgEl) {\n        throw new Error(\"SVG element not found\");\n    }\n    const rect = svgEl.getBoundingClientRect();\n    const width = rect.width;\n    const height = rect.height;\n    // Set width and height explictly since in firefox it gets set to 0\n    // if the width and height are not expilcitly set\n    // eg in some cases like er Diagram, gnatt, width and height is set as 100%\n    // which sets the dimensions as 0 in firefox and thus the diagram isn't rendered\n    svgEl.setAttribute(\"width\", `${width}`);\n    svgEl.setAttribute(\"height\", `${height}`);\n    // Convert SVG to image\n    const mimeType = \"image/svg+xml\";\n    const decoded = unescape(encodeURIComponent(svgEl.outerHTML));\n    const base64 = btoa(decoded);\n    const dataURL = `data:image/svg+xml;base64,${base64}`;\n    const graphImage = {\n        type: \"graphImage\",\n        mimeType,\n        dataURL,\n        width,\n        height,\n    };\n    return graphImage;\n};\nexport const parseMermaid = async (definition, config = MERMAID_CONFIG) => {\n    mermaid.initialize({ ...MERMAID_CONFIG, ...config });\n    // Parse the diagram\n    const diagram = await mermaid.mermaidAPI.getDiagramFromText(encodeEntities(definition));\n    // Render the SVG diagram\n    const { svg } = await mermaid.render(\"mermaid-to-excalidraw\", definition);\n    // Append Svg to DOM\n    const svgContainer = document.createElement(\"div\");\n    svgContainer.setAttribute(\"style\", `opacity: 0; position: relative; z-index: -1;`);\n    svgContainer.innerHTML = svg;\n    svgContainer.id = \"mermaid-diagram\";\n    document.body.appendChild(svgContainer);\n    let data;\n    switch (diagram.type) {\n        case \"flowchart-v2\": {\n            data = parseMermaidFlowChartDiagram(diagram, svgContainer);\n            break;\n        }\n        case \"sequence\": {\n            data = parseMermaidSequenceDiagram(diagram, svgContainer);\n            break;\n        }\n        case \"classDiagram\": {\n            data = parseMermaidClassDiagram(diagram, svgContainer);\n            break;\n        }\n        // fallback to image if diagram type not-supported\n        default: {\n            data = convertSvgToGraphImage(svgContainer);\n        }\n    }\n    svgContainer.remove();\n    return data;\n};\n", "import { DEFAULT_FONT_SIZE } from \"./constants.js\";\nimport { graphToExcalidraw } from \"./graphToExcalidraw.js\";\nimport { parseMermaid } from \"./parseMermaid.js\";\nconst parseMermaidToExcalidraw = async (definition, config) => {\n    const mermaidConfig = config || {};\n    const fontSize = parseInt(mermaidConfig.themeVariables?.fontSize ?? \"\") || DEFAULT_FONT_SIZE;\n    const parsedMermaidData = await parseMermaid(definition, {\n        ...mermaidConfig,\n        themeVariables: {\n            ...mermaidConfig.themeVariables,\n            // Multiplying by 1.25 to increase the font size by 25% and render correctly in Excalidraw\n            fontSize: `${fontSize * 1.25}px`,\n        },\n    });\n    // Only font size supported for excalidraw elements\n    const excalidrawElements = graphToExcalidraw(parsedMermaidData, {\n        fontSize,\n    });\n    return excalidrawElements;\n};\nexport { parseMermaidToExcalidraw };\n"],
  "mappings": "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",
  "names": ["require_dist", "removeMarkdown", "VERTEX_TYPE", "LABEL_STYLE_PROPERTY", "CONTAINER_STYLE_PROPERTY", "transformX", "transformY", "getStrokeStyle", "node"]
}
