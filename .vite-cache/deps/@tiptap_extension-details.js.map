{
  "version": 3,
  "sources": ["../../node_modules/@tiptap/extension-details/src/helpers/isNodeVisible.ts", "../../node_modules/@tiptap/extension-details/src/helpers/findClosestVisibleNode.ts", "../../node_modules/@tiptap/extension-details/src/helpers/setGapCursor.ts", "../../node_modules/@tiptap/extension-details/src/details.ts"],
  "sourcesContent": ["import { Editor } from '@tiptap/core'\n\nexport const isNodeVisible = (position: number, editor: Editor): boolean => {\n  const node = editor.view.domAtPos(position).node as HTMLElement\n  const isOpen = node.offsetParent !== null\n\n  return isOpen\n}\n", "import { Editor, Predicate } from '@tiptap/core'\nimport { Node as ProseMirrorNode, ResolvedPos } from '@tiptap/pm/model'\n\nimport { isNodeVisible } from './isNodeVisible.js'\n\nexport const findClosestVisibleNode = ($pos: ResolvedPos, predicate: Predicate, editor: Editor): ({\n  pos: number,\n  start: number,\n  depth: number,\n  node: ProseMirrorNode,\n} | undefined) => {\n  for (let i = $pos.depth; i > 0; i -= 1) {\n    const node = $pos.node(i)\n    const match = predicate(node)\n    const isVisible = isNodeVisible($pos.start(i), editor)\n\n    if (match && isVisible) {\n      return {\n        pos: i > 0 ? $pos.before(i) : 0,\n        start: $pos.start(i),\n        depth: i,\n        node,\n      }\n    }\n  }\n}\n", "import { Editor, findChildren, findParentNode } from '@tiptap/core'\nimport { GapCursor } from '@tiptap/pm/gapcursor'\nimport { ResolvedPos } from '@tiptap/pm/model'\nimport { Selection } from '@tiptap/pm/state'\n\nimport { isNodeVisible } from './isNodeVisible.js'\n\nexport const setGapCursor = (editor: Editor, direction: 'down' | 'right') => {\n  const { state, view, extensionManager } = editor\n  const { schema, selection } = state\n  const { empty, $anchor } = selection\n  const hasGapCursorExtension = !!extensionManager.extensions.find(extension => extension.name === 'gapCursor')\n\n  if (\n    !empty\n    || $anchor.parent.type !== schema.nodes.detailsSummary\n    || !hasGapCursorExtension\n  ) {\n    return false\n  }\n\n  if (\n    direction === 'right'\n    && $anchor.parentOffset !== ($anchor.parent.nodeSize - 2)\n  ) {\n    return false\n  }\n\n  const details = findParentNode(node => node.type === schema.nodes.details)(selection)\n\n  if (!details) {\n    return false\n  }\n\n  const detailsContent = findChildren(details.node, node => node.type === schema.nodes.detailsContent)\n\n  if (!detailsContent.length) {\n    return false\n  }\n\n  const isOpen = isNodeVisible(details.start + detailsContent[0].pos + 1, editor)\n\n  if (isOpen) {\n    return false\n  }\n\n  const $position = state.doc.resolve(details.pos + details.node.nodeSize)\n  const $validPosition = GapCursor.findFrom($position, 1, false) as unknown as (null | ResolvedPos)\n\n  if (!$validPosition) {\n    return false\n  }\n\n  const { tr } = state\n  const gapCursorSelection = new GapCursor($validPosition) as Selection\n\n  tr.setSelection(gapCursorSelection)\n  tr.scrollIntoView()\n  view.dispatch(tr)\n\n  return true\n}\n", "import {\n  defaultBlockAt,\n  findChildren,\n  findParentNode,\n  isActive,\n  mergeAttributes,\n  Node,\n} from '@tiptap/core'\nimport {\n  Plugin,\n  PluginKey,\n  Selection,\n  TextSelection,\n} from '@tiptap/pm/state'\nimport type { ViewMutationRecord } from '@tiptap/pm/view'\n\nimport { findClosestVisibleNode } from './helpers/findClosestVisibleNode.js'\nimport { isNodeVisible } from './helpers/isNodeVisible.js'\nimport { setGapCursor } from './helpers/setGapCursor.js'\n\nexport interface DetailsOptions {\n  /**\n   * Specify if the open status should be saved in the document. Defaults to `false`.\n   */\n  persist: boolean,\n  /**\n   * Specifies a CSS class that is set when toggling the content. Defaults to `is-open`.\n   */\n  openClassName: string,\n  /**\n   * Custom HTML attributes that should be added to the rendered HTML tag.\n   */\n  HTMLAttributes: {\n    [key: string]: any\n  },\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    details: {\n      /**\n       * Set a details node\n       */\n      setDetails: () => ReturnType,\n      /**\n       * Unset a details node\n       */\n      unsetDetails: () => ReturnType,\n    }\n  }\n}\n\nexport const Details = Node.create<DetailsOptions>({\n  name: 'details',\n\n  content: 'detailsSummary detailsContent',\n\n  group: 'block',\n\n  defining: true,\n\n  isolating: true,\n\n  allowGapCursor: false,\n\n  addOptions() {\n    return {\n      persist: false,\n      openClassName: 'is-open',\n      HTMLAttributes: {},\n    }\n  },\n\n  addAttributes() {\n    if (!this.options.persist) {\n      return []\n    }\n\n    return {\n      open: {\n        default: false,\n        parseHTML: element => element.hasAttribute('open'),\n        renderHTML: ({ open }) => {\n          if (!open) {\n            return {}\n          }\n\n          return { open: '' }\n        },\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      {\n        tag: 'details',\n      },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      'details',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ]\n  },\n\n  addNodeView() {\n    return ({\n      editor,\n      getPos,\n      node,\n      HTMLAttributes,\n    }) => {\n      const dom = document.createElement('div')\n      const attributes = mergeAttributes(\n        this.options.HTMLAttributes,\n        HTMLAttributes,\n        {\n          'data-type': this.name,\n        },\n      )\n\n      Object.entries(attributes).forEach(([key, value]) => dom.setAttribute(key, value))\n\n      const toggle = document.createElement('button')\n\n      toggle.type = 'button'\n\n      dom.append(toggle)\n\n      const content = document.createElement('div')\n\n      dom.append(content)\n\n      const toggleDetailsContent = (setToValue?: boolean) => {\n        if (setToValue !== undefined) {\n          if (setToValue) {\n            if (dom.classList.contains(this.options.openClassName)) {\n              return\n            }\n            dom.classList.add(this.options.openClassName)\n          } else {\n            if (!dom.classList.contains(this.options.openClassName)) {\n              return\n            }\n            dom.classList.remove(this.options.openClassName)\n          }\n        } else {\n          dom.classList.toggle(this.options.openClassName)\n        }\n\n        const event = new Event('toggleDetailsContent')\n        const detailsContent = content.querySelector(':scope > div[data-type=\"detailsContent\"]')\n\n        detailsContent?.dispatchEvent(event)\n      }\n\n      if (node.attrs.open) {\n        setTimeout(() => toggleDetailsContent())\n      }\n\n      toggle.addEventListener('click', () => {\n        toggleDetailsContent()\n\n        if (!this.options.persist) {\n          editor.commands\n            .focus(undefined, { scrollIntoView: false })\n\n          return\n        }\n\n        if (editor.isEditable && typeof getPos === 'function') {\n          const { from, to } = editor.state.selection\n\n          editor\n            .chain()\n            .command(({ tr }) => {\n              const pos = getPos()\n              const currentNode = tr.doc.nodeAt(pos)\n\n              if (currentNode?.type !== this.type) {\n                return false\n              }\n\n              tr.setNodeMarkup(pos, undefined, {\n                open: !currentNode.attrs.open,\n              })\n\n              return true\n            })\n            .setTextSelection({\n              from,\n              to,\n            })\n            .focus(undefined, { scrollIntoView: false })\n            .run()\n        }\n      })\n\n      return {\n        dom,\n        contentDOM: content,\n        ignoreMutation(mutation: ViewMutationRecord) {\n          if (mutation.type === 'selection') {\n            return false\n          }\n\n          return !dom.contains(mutation.target) || dom === mutation.target\n        },\n        update: updatedNode => {\n          if (updatedNode.type !== this.type) {\n            return false\n          }\n\n          // Only update the open state if set\n          if (updatedNode.attrs.open !== undefined) {\n            toggleDetailsContent(updatedNode.attrs.open)\n          }\n\n          return true\n        },\n      }\n    }\n  },\n\n  addCommands() {\n    return {\n      setDetails: () => ({ state, chain }) => {\n        const { schema, selection } = state\n        const { $from, $to } = selection\n        const range = $from.blockRange($to)\n\n        if (!range) {\n          return false\n        }\n\n        const slice = state.doc.slice(range.start, range.end)\n        const match = schema.nodes.detailsContent.contentMatch.matchFragment(slice.content)\n\n        if (!match) {\n          return false\n        }\n\n        const content = slice.toJSON()?.content || []\n\n        return chain()\n          .insertContentAt({ from: range.start, to: range.end }, {\n            type: this.name,\n            content: [\n              {\n                type: 'detailsSummary',\n              },\n              {\n                type: 'detailsContent',\n                content,\n              },\n            ],\n          })\n          .setTextSelection(range.start + 2)\n          .run()\n      },\n\n      unsetDetails: () => ({ state, chain }) => {\n        const { selection, schema } = state\n        const details = findParentNode(node => node.type === this.type)(selection)\n\n        if (!details) {\n          return false\n        }\n\n        const detailsSummaries = findChildren(details.node, node => node.type === schema.nodes.detailsSummary)\n        const detailsContents = findChildren(details.node, node => node.type === schema.nodes.detailsContent)\n\n        if (!detailsSummaries.length || !detailsContents.length) {\n          return false\n        }\n\n        const detailsSummary = detailsSummaries[0]\n        const detailsContent = detailsContents[0]\n        const from = details.pos\n        const $from = state.doc.resolve(from)\n        const to = from + details.node.nodeSize\n        const range = { from, to }\n        const content = detailsContent.node.content.toJSON() as [] || []\n        const defaultTypeForSummary = $from.parent.type.contentMatch.defaultType\n\n        // TODO: this may break for some custom schemas\n        const summaryContent = defaultTypeForSummary?.create(null, detailsSummary.node.content).toJSON()\n        const mergedContent = [\n          summaryContent,\n          ...content,\n        ]\n\n        return chain()\n          .insertContentAt(range, mergedContent)\n          .setTextSelection(from + 1)\n          .run()\n      },\n    }\n  },\n\n  addKeyboardShortcuts() {\n    return {\n      Backspace: () => {\n        const { schema, selection } = this.editor.state\n        const { empty, $anchor } = selection\n\n        if (!empty || $anchor.parent.type !== schema.nodes.detailsSummary) {\n          return false\n        }\n\n        // for some reason safari removes the whole text content within a `<summary>`tag on backspace\n        // so we have to remove the text manually\n        // see: https://discuss.prosemirror.net/t/safari-backspace-bug-with-details-tag/4223\n        if ($anchor.parentOffset !== 0) {\n          return this.editor.commands.command(({ tr }) => {\n            const from = $anchor.pos - 1\n            const to = $anchor.pos\n\n            tr.delete(from, to)\n\n            return true\n          })\n        }\n\n        return this.editor.commands.unsetDetails()\n      },\n\n      // Creates a new node below it if it is closed.\n      // Otherwise inside `DetailsContent`.\n      Enter: ({ editor }) => {\n        const { state, view } = editor\n        const { schema, selection } = state\n        const { $head } = selection\n\n        if ($head.parent.type !== schema.nodes.detailsSummary) {\n          return false\n        }\n\n        const isVisible = isNodeVisible($head.after() + 1, editor)\n        const above = isVisible\n          ? state.doc.nodeAt($head.after())\n          : $head.node(-2)\n\n        if (!above) {\n          return false\n        }\n\n        const after = isVisible\n          ? 0\n          : $head.indexAfter(-1)\n        const type = defaultBlockAt(above.contentMatchAt(after))\n\n        if (!type || !above.canReplaceWith(after, after, type)) {\n          return false\n        }\n\n        const node = type.createAndFill()\n\n        if (!node) {\n          return false\n        }\n\n        const pos = isVisible\n          ? $head.after() + 1\n          : $head.after(-1)\n        const tr = state.tr.replaceWith(pos, pos, node)\n        const $pos = tr.doc.resolve(pos)\n        const newSelection = Selection.near($pos, 1)\n\n        tr.setSelection(newSelection)\n        tr.scrollIntoView()\n        view.dispatch(tr)\n\n        return true\n      },\n\n      // The default gapcursor implementation can’t handle hidden content, so we need to fix this.\n      ArrowRight: ({ editor }) => {\n        return setGapCursor(editor, 'right')\n      },\n\n      // The default gapcursor implementation can’t handle hidden content, so we need to fix this.\n      ArrowDown: ({ editor }) => {\n        return setGapCursor(editor, 'down')\n      },\n    }\n  },\n\n  addProseMirrorPlugins() {\n    return [\n      // This plugin prevents text selections within the hidden content in `DetailsContent`.\n      // The cursor is moved to the next visible position.\n      new Plugin({\n        key: new PluginKey('detailsSelection'),\n        appendTransaction: (transactions, oldState, newState) => {\n          const { editor, type } = this\n          const selectionSet = transactions.some(transaction => transaction.selectionSet)\n\n          if (\n            !selectionSet\n            || !oldState.selection.empty\n            || !newState.selection.empty\n          ) {\n            return\n          }\n\n          const detailsIsActive = isActive(newState, type.name)\n\n          if (!detailsIsActive) {\n            return\n          }\n\n          const { $from } = newState.selection\n          const isVisible = isNodeVisible($from.pos, editor)\n\n          if (isVisible) {\n            return\n          }\n\n          const details = findClosestVisibleNode($from, node => node.type === type, editor)\n\n          if (!details) {\n            return\n          }\n\n          const detailsSummaries = findChildren(details.node, node => node.type === newState.schema.nodes.detailsSummary)\n\n          if (!detailsSummaries.length) {\n            return\n          }\n\n          const detailsSummary = detailsSummaries[0]\n          const selectionDirection = oldState.selection.from < newState.selection.from\n            ? 'forward'\n            : 'backward'\n          const correctedPosition = selectionDirection === 'forward'\n            ? details.start + detailsSummary.pos\n            : details.pos + detailsSummary.pos + detailsSummary.node.nodeSize\n          const selection = TextSelection.create(newState.doc, correctedPosition)\n          const transaction = newState.tr.setSelection(selection)\n\n          return transaction\n        },\n      }),\n    ]\n  },\n})\n"],
  "mappings": "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",
  "names": ["transaction"]
}
